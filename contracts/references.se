# Reference Database

# TODO
# Unsure I like this data structure, specifically the "insured" and "insurer" naming
# Review code against original
# No False Claims scenario

data owner
data insured[2^160](max_liability, locked, insurer[2^160](max_liability, premium, last_updated, locked))


# Constants
macro E_INVALID_INSURED_ADDRESS():              901
macro E_INVALID_INSURER_ADDRESS():              902
macro E_INVALID_AMOUNT():                       903
macro E_RECORD_NOT_FOUND():                     910
macro E_PREMIUM_MISMATCH():                     920
macro E_NO_AVAILABLE_LIABILITY_FOR_INSURED():   921
macro E_NO_AVAILABLE_LIABILITY_FOR_INSURER():   922
macro E_NOT_IMPLEMENTED():                      999

# Macros
macro INSURED_INSURER(): self.insured[insured].insurer[msg.sender]

def init():
    self.owner = msg.sender

def deposit():
    self.insured[msg.sender].max_liability += msg.value
    return 1

def withdraw(amount):
    if amount == 0:
        return E_INVALID_AMOUNT()

    if amount > self.insured[msg.sender].max_liability - self.insured[msg.sender].locked:
        return E_NO_AVAILABLE_LIABILITY_FOR_INSURER()

    self.insured[msg.sender].max_liability -= amount

    send(msg.sender, amount) # Wei
    return 1

def set(insured, max_liability, premium):
    if insured == 0 or !self.insured[insured].max_liability:
        return E_INVALID_INSURED_ADDRESS()

    self.insured[insured].insurer[msg.sender].max_liability = max_liability
    self.insured[insured].insurer[msg.sender].premium       = premium
    self.insured[insured].insurer[msg.sender].last_updated  = block.timestamp

    # TODO add list of references
    return 1

def lock(insured, liability, premium):
    if insured == 0 or !self.insured[insured].max_liability:
        return E_INVALID_INSURED_ADDRESS()

    # INSURED_INSURER() = self.insured[insured].insurer[msg.sender]

    if INSURED_INSURER().last_updated == 0:
        return E_RECORD_NOT_FOUND()

    if premium != INSURED_INSURER().premium:
        # premium mismatch
        return E_PREMIUM_MISMATCH()

    # TODO charge premium

    # Insured Max Liability
    if liability > INSURED_INSURER().max_liability - INSURED_INSURER().locked:
        return E_NO_AVAILABLE_LIABILITY_FOR_INSURED()

    # Insurer Max Liability
    if liability > self.insured[msg.sender].max_liability - self.insured[msg.sender].locked:
        return E_NO_AVAILABLE_LIABILITY_FOR_INSURER()

    self.insured[insured].insurer[msg.sender].locked    += liability
    self.insured[insured].locked                        += liability

    return 1

def release(insured, liability, success):
    if insured == 0 or !self.insured[insured].max_liability:
        return E_INVALID_INSURED_ADDRESS()

    # INSURED_INSURER() = self.insured[insured].insurer[msg.sender]

    if INSURED_INSURER().last_updated == 0:
        return E_RECORD_NOT_FOUND()

    self.insured[insured].insurer[msg.sender].locked    -= liability
    self.insured[insured].locked                        -= liability

    if success == 0:
        self.insured[insured].insurer[msg.sender].max_liability    -= liability
        self.insured[insured].max_liability                        -= liability

        # TODO pay to insured / claimant

    return 1


def suicide():
    if msg.sender == self.owner:
        suicide(msg.sender)